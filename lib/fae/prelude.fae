import fae::intrinsics::create_slice_mut

#intrinsic
generic T
fn size_of(): isize

#intrinsic
generic T
fn alignment_of(): isize

generic T
fn null_pointer(): &mut T {
	return 0.(&mut T)	
}

generic T
fn null_slice(): []mut T {
	let null = null_pointer<T>()
	return create_slice_mut<T>(null, 0)
}

generic T
fn offset_pointer(pointer: &T, by_bytes: isize): &T {
	return (pointer.(usize) + by_bytes.(usize)).(&T)
}

generic T
fn offset_pointer_mut(pointer: &mut T, by_bytes: isize): &mut T {
	return (pointer.(usize) + by_bytes.(usize)).(&mut T)
}

fn panic(): noreturn {
	import fae::libc::DlInfo, StdErrFile, exit, backtrace, dladdr, fprintf

	fprintf(StdErrFile.*, "\n\nFae thread panicked!\n".pointer)
	fprintf(StdErrFile.*, "Function backtrace:\n".pointer)

	let null = null_pointer<void>()
	// 50 items
	let buffer = []&void {
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
	}

	let symbol_count = backtrace(buffer.pointer, buffer.length.(i32)).(isize)
	let symbols = buffer[0..symbol_count]

	const Indentation = "  "
	const Error = "<error>"
	const Unknown = "<unknown>"
	const Spacer = "  "

	enum Symbol {
		Error
		Unknown { path: &u8 }
		Found {
			name: str
			path: &u8
		}
	}

	// 50 items
	let buffer = []Symbol {
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
	}

	mut longest_width: isize = 0
	fn handle_width(longest_width: &mut isize, width: isize) {
		if width > longest_width.* => longest_width.* = width
	}

	fn print_width(width: isize) {
		mut index: isize = 0
		while index < width { 
			index += 1
			fprintf(StdErrFile.*, " ".pointer)
		}
	}

	mut index: isize = 0
	while index < symbols.length {
		let address = symbols[index]
		let entry = buffer[index].&mut
		index += 1

		mut info = DlInfo {
			dli_fname: null_pointer<u8>()
			dli_fbase: null_pointer<void>()
			dli_sname: null_pointer<u8>()
			dli_saddr: null_pointer<void>()
		}

		if dladdr(address, info.&mut) == 0 {
			entry.* = Symbol.Error
			handle_width(longest_width.&mut, Error.length)
			continue
		}
		
		let path = info.dli_fname

		if info.dli_saddr.(usize) == 0 {
			entry.* = Symbol.Unknown { path }
			handle_width(longest_width.&mut, Unknown.length)
		} else {
			let name_length = fae::libc::strlen(info.dli_sname).(isize)
			let name = fae::intrinsics::create_str(info.dli_sname, name_length)
			entry.* = Symbol.Found { name, path }
			handle_width(longest_width.&mut, name_length)
		}
	}

	let symbols = buffer[0..symbol_count]

	mut index: isize = 0
	while index < symbols.length {
		let symbol = symbols[index]
		index += 1

		mut current_width: isize = 0
		mut path: &u8 = "".pointer

		match symbol {
			Error {
				fprintf(StdErrFile.*, "%s%s\n".pointer, Indentation.pointer, Error.pointer)
				continue
			}

			Unknown {
				fprintf(StdErrFile.*, "%s%s".pointer, Indentation.pointer, Unknown.pointer)
				current_width = Unknown.length
				path = symbol.path
			}

			Found {
				fprintf(StdErrFile.*, "%s%s".pointer, Indentation.pointer, symbol.name.pointer)
				current_width = symbol.name.length
				path = symbol.path
			}
		}

		print_width(longest_width - current_width)
		fprintf(StdErrFile.*, "%s(%s)\n".pointer, Spacer.pointer, path	)
	}

	if symbol_count == 0 {
		fprintf(StdErrFile.*, "%s<missing backtrace>\n".pointer, Indentation.pointer)
	}
	fprintf(StdErrFile.*, "\n".pointer)

	fae::intrinsics::debugger_break()
	exit(-1)
}

#lang "range_type"
struct Range {
	start: isize
	end: isize
}

// TODO: This is temporary intermediate tool until there is "blessed" optional semantics
// baked into the language itself
generic T
enum Option {
	None
	Some(T)
}

method Option
fn unwrap(): T {
	match self {
		some: Some => return some

		None {
			let stderr = fae::libc::StdErrFile.*
			fae::libc::fprintf(stderr, "Panic: Attempted to unwrap an empty Option\n".pointer)
			fae::libc::fflush(stderr)
			fae::libc::exit(-1)
		}
	}
}
