export "main"
fn fae_main(_argc: i32, _argv: &&u8): i32 {
	fae::intrinsics::user_main_function()
	return 0
}

#lang "slice_index_out_of_bounds"
fn slice_index_out_of_bounds(length: isize, index: isize) {
	panicf(f"Slice index {index} is out of range of slice with length {length}")
}

#lang "slice_range_inverted"
fn slice_range_inverted(range: Range) {
	panicf(f"Slice range start {range.start} is larger than end {range.end}")
}

#lang "slice_range_start_out_of_bounds"
fn slice_range_start_out_of_bounds(length: isize, start: isize) {
	panicf(f"Slice range start {start} is out of range of slice with length {length}")
}

#lang "slice_range_end_out_of_bounds"
fn slice_range_end_out_of_bounds(length: isize, end: isize) {
	panicf(f"Slice range end {end} is out of range of slice with length {length}")
}

#lang "for_range_inverted"
fn for_range_inverted(range: Range) {
	panicf(f"For loop range start {range.start} is larger than end {range.end}")
}

fn panic_impl(message: fstr): noreturn {
	import fae::libc::DlInfo, StdErrFile, exit, backtrace, dladdr, strlen

	eprintln(f"Fae thread panicked: {message}")	

	// Backtraces can differ between platforms, optimization level, and change
	// when code is refactored. Therefore they should not be included in panic
	// messages when in compiler tests
	if fae::intrinsics::is_compiler_test() => exit(-1)

	eprintln("Function backtrace:")

	let null = null_pointer<void>()
	// 50 items
	let addresses = []&void {
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
	}

	let symbol_count = backtrace(addresses.pointer, addresses.length.(i32)).(isize)
	let addresses = addresses[0..symbol_count]

	const Indentation = "  "
	const Error = "<error>"
	const Unknown = "<unknown>"
	const Spacer = "  "

	enum Symbol {
		Error
		Unknown { path: str }
		Found { name: str,  path: str }
	}

	// 50 items
	let symbols = []Symbol {
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
		Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error, Symbol.Error,
	}
	let symbols = symbols[0..symbol_count]

	mut longest_width: isize = 0
	fn handle_width(longest_width: &mut isize, width: isize) {
		if width > longest_width.* => longest_width.* = width
	}

	fn print_width(width: isize) {
		for _ in 0..width => eprint(" ")
	}

	for address, index in addresses {
		mut info = DlInfo {
			dli_fname: null_pointer<u8>()
			dli_fbase: null_pointer<void>()
			dli_sname: null_pointer<u8>()
			dli_saddr: null_pointer<void>()
		}

		if dladdr(address, info.&mut) == 0 {
			symbols[index] = Symbol.Error
			handle_width(longest_width.&mut, Error.length)
			continue
		}

		let path_length = strlen(info.dli_fname).(isize)
		let path = fae::intrinsics::create_str(info.dli_fname, path_length)

		if info.dli_saddr.(usize) == 0 {
			symbols[index] = Symbol.Unknown { path }
			handle_width(longest_width.&mut, Unknown.length)
		} else {
			let name_length = strlen(info.dli_sname).(isize)
			let name = fae::intrinsics::create_str(info.dli_sname, name_length)
			symbols[index] = Symbol.Found { name, path }
			handle_width(longest_width.&mut, name_length)
		}
	}

	for symbol in symbols {
		mut current_width: isize = 0
		mut path = ""

		match symbol {
			Error {
				eprintln(f"{Indentation}{Error}")
				continue
			}

			Unknown {
				eprint(f"{Indentation}{Unknown}")
				current_width = Unknown.length
				path = symbol.path
			}

			Found {
				eprint(f"{Indentation}{symbol.name}")
				current_width = symbol.name.length
				path = symbol.path
			}
		}

		print_width(longest_width - current_width)
		eprintln(f"{Spacer}({path})")
	}

	if symbol_count == 0 {
		eprintln(f"{Indentation}<missing backtrace>")
	}
	eprintln("")

	fae::intrinsics::debugger_break()
	exit(-1)
}

