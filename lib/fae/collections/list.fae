import fae::memory::free_slice, reallocate_region

const GrowthFactor = 2
const InitialGrowth = 8

generic T
struct List {
	items: []mut T readable
	capacity: isize readable
}

method static List
fn new(): List<T> {
	return List<T> {
		items: null_slice<T>()
		capacity: 0
	}
}

method mut List
fn push(item: T) {
	self.reserve_at_least(self.items.length + 1)
	let index = self.items.length
	self.items.length += 1
	self.items[index] = item
}

method mut List
fn clear() {
	self.items.length = 0
}

method mut List
fn truncate(to_length: isize) {
	if to_length >= self.items.length => return
	self.items.length = to_length
}

method mut List
fn set_length(to_length: isize) {
	self.items.length = to_length
}

method mut List
fn reserve_exact(new_capacity: isize) {
	assertf(new_capacity > 0, f"{new_capacity}")
	if new_capacity <= self.capacity => return

	reallocate_region<T>(self.items.pointer.&mut, new_capacity)
	self.capacity = new_capacity
}

method mut List
fn reserve_at_least(mut new_capacity: isize) {
	assertf(new_capacity > 0, f"{new_capacity}")
	if new_capacity <= self.capacity => return

	if new_capacity < InitialGrowth => new_capacity = InitialGrowth
	if new_capacity < self.capacity * GrowthFactor {
		new_capacity = self.capacity * GrowthFactor
	}

	reallocate_region<T>(self.items.pointer.&mut, new_capacity)
	self.capacity = new_capacity
}

method mut List
fn extend_from_slice(slice: []T) {
	let result_length = self.items.length + slice.length
	self.reserve_at_least(result_length)
	let destination = self.items[self.items.length..result_length]
	fae::memory::copy_slice_into<T>(slice, destination)
	self.items.length = result_length
}

method mut List
fn remove_range(range: Range) {
	let source = self.items[range.end..self.items.length]
	let destination = self.items[range.start..self.items.length]
	fae::memory::move_slice_into<T>(source, destination)
	self.truncate(range.start + source.length)
}

method List
fn is_empty(): bool {
	return self.items.length <= 0
}

method List
fn has_items(): bool {
	return self.items.length > 0
}

method List
fn first(): Option<T> {
	if self.is_empty() => return .None
	return .Some(self.items[0])
}

method List
fn first_ref(): Option<&T> {
	if self.is_empty() => return .None
	return .Some(self.items[0].&)
}

method mut List
fn first_mut(): Option<&mut T> {
	if self.is_empty() => return .None
	return .Some(self.items[0].&mut)
}

method List
fn last(): Option<T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1]
	return .Some(value)
}

method List
fn last_ref(): Option<&T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1].&
	return .Some(value)
}

method mut List
fn last_mut(): Option<&mut T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1].&mut
	return .Some(value)
}

method mut List
fn pop(): Option<T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1]
	self.items.length -= 1
	return .Some(value)
}

method List
fn get(index: isize): T {
	return self.items[index]
}

method List
fn get_ref(index: isize): &T {
	return self.items[index].&
}

method mut List
fn get_mut(index: isize): &mut T {
	return self.items[index].&mut
}

method List
fn slice(range: Range): []T {
	return self.items[range]
}

method mut List
fn slice_mut(range: Range): []mut T {
	return self.items[range]
}

method mut List
fn free() {
	free_slice<T>(self.items)
}
