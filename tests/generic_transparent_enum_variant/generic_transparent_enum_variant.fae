// Important note: This is not how error handling is intended to be done in Fae
// This is a contrived program intended to test generic enums

import fae::stdout::print_i32, print_newline

fn divide(value: i32, by: i32): Enum<i32, []u8> {
	if by == 0 => return .Error("Divide by zero")
	return Enum<i32, []u8>.Ok(value / by)
}

fn main() {
	match divide(4, 0) {
		result: Ok {
			print_i32(result)
			print_newline()
		}

		error: Error => print_error<i32>(error)
	}

	let result = divide(4, 0)
	if result is Ok {
		print_i32(result)
		print_newline()
	} else if result is error: Error {
		print_error<i32>(error)
	}

	match divide(4, 2) {
		result: Ok {
			print_i32(result)
			print_newline()
		}

		error: Error => print_error<i32>(error)
	}

	let result = divide(4, 2)
	if result is Ok {
		print_i32(result)
		print_newline()
	} else if result is error: Error {
		print_error<i32>(error)
	}
}

generic T, E
enum Enum {
	Ok(T)
	Error(E)
}

generic T
fn print_error(arg: []u8) {
	import fae::stdout::print_string

	print_string("Error: ")
	print_string(arg)
	print_newline()
}
