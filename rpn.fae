 const MAX_LINE = 1024 * 4

fn main()
throws {
    mut buffer = Buffer.new(capacity: MAX_LINE)
    defer buffer.destroy()?

    mut machine = Machine.new()
    defer machine.destroy()?

    while true {
        defer machine.reset()

        let byte_count = prompt(buffer: buffer&mut)
        let input = buffer[~byte_count]

        mut tokenizer = Tokenizer.new()
        while tokenizer.next_range(input)? is Some(range) {
            let token = input[range]
            if token == "exit" => return
            machine.interpret(token)
        }

        machine.print_results()
    }
}

fn prompt(buffer &mut Buffer) usize {
    print(">>> ")
    let read = std.io.read_stdin(buffer.slice_mut(~))
    println("")
    return read
}

struct Tokenizer {
    index usize viewable
}

static Tokenizer
fn new() Tokenizer {
    return Tokenizer {
        index = 0
    }
}

method mut Tokenizer
fn next_range(input &[u8]) Range?
throws {
    while .index + 1 < input.len and input.[.index + 1]?.is_ascii_whitespace() {
        .index += 1
    }
    
    let start = .index
    while .index + 1 < input.len and input.[.index + 1]?.is_ascii_whitespace()! {
        .index += 1
    }
    
    if start == .index {
        return None
    } else {
        return start:.index
    }
}

struct Machine {
    stack List[i64] private
}

static Machine
fn new() Machine {
    return Machine {
        stack = List.new()
    }
}

method mut Machine
fn reset() {
    .stack.clear()
}

method mut Machine
fn interpret(token: &[u8]) {
    when token is "+" {
        let left, let right = .pop_args()?
        .stack.push(left + right)
    }
    else is "-" {
        let left, let right = .pop_args()?
        .stack.push(left - right)
    }
    else is "*" {
        let left, let right = .pop_args()?
        .stack.push(left * right)
    }
    else is "/" {
        let left, let right = .pop_args()?
        .stack.push(left / right)
    }
    else {
        let number = i64.parse_str(str.from_bytes(token))
        when number is Err(_) => return
        .stack.push(number)
    }
}

method mut Machine private
fn pop_args() (left i64, right i64)
throws {
    let right = .stack.pop()
    let left = .stack.pop()
    return (left, right)
}

method Machine
fn print_results() {
    if .stack.is_empty() => println("No result")
    else => println("{}", .stack.pop().verify())
}
