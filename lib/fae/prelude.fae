import fae::intrinsics::create_slice_mut

#intrinsic
generic T
fn size_of(): isize

#intrinsic
generic T
fn alignment_of(): isize

generic T
fn null_pointer(): &mut T {
	return 0.(&mut T)	
}

generic T
fn null_slice(): []mut T {
	let null = null_pointer<T>()
	return create_slice_mut<T>(null, 0)
}

generic T
fn offset_pointer(pointer: &T, by_bytes: isize): &T {
	return (pointer.(isize) + by_bytes).(&T)
}

generic T
fn offset_pointer_mut(pointer: &mut T, by_bytes: isize): &mut T {
	return (pointer.(isize) + by_bytes).(&mut T)
}

fn print(message: fstr) {
	let handle = fae::libc::StdOutFile
	fae::string::format::print_to_file_handle(handle, message)
}

fn println(message: fstr) {
	let handle = fae::libc::StdOutFile
	let message = f"{message}\n"
	fae::string::format::print_to_file_handle(handle, message)
}

fn eprint(message: fstr) {
	let handle = fae::libc::StdErrFile
	fae::string::format::print_to_file_handle(handle, message)
}

fn eprintln(message: fstr) {
	let handle = fae::libc::StdErrFile
	let message = f"{message}\n"
	fae::string::format::print_to_file_handle(handle, message)
}

fn panic(): noreturn {
	fae::runtime::panic_impl("Explicit panic")
}

fn panicf(message: fstr): noreturn {
	fae::runtime::panic_impl(message)
}

fn exit_success() {
	fae::libc::exit(0)
}

fn error(): noreturn {
	fae::libc::exit(-1)
}

fn errorf(message: fstr): noreturn {
	eprintln(message)
	fae::libc::exit(-1)
}

fn assert(value: bool) {
	if value.! => panicf("Assertion failed")
}

fn assertf(value: bool, message: fstr) {
	if value.! => panicf(f"Assertion failed: {message}")
}

#lang "range_type"
struct Range {
	start: isize
	end: isize
}

// TODO: This is temporary intermediate tool until there is "blessed" optional semantics
// baked into the language itself
generic T
enum Option {
	None
	Some(T)
}

method Option
fn unwrap(): T {
	match self {
		some: Some => return some
		None => panicf("Attempted to unwrap an empty Option")
	}
}
