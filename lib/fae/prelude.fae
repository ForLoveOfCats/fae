import fae::intrinsics::create_slice_mut

#intrinsic
generic T
fn size_of(): isize

#intrinsic
generic T
fn alignment_of(): isize

generic T
fn null_pointer(): &mut T {
	return 0.(&mut T)	
}

generic T
fn null_slice(): []mut T {
	let null = null_pointer<T>()
	return create_slice_mut<T>(null, 0)
}

generic T
fn offset_pointer(pointer: &T, by_bytes: isize): &T {
	return (pointer.(usize) + by_bytes.(usize)).(&T)
}

generic T
fn offset_pointer_mut(pointer: &mut T, by_bytes: isize): &mut T {
	return (pointer.(usize) + by_bytes.(usize)).(&mut T)
}

fn panic(): noreturn {
	import fae::libc::DlInfo, StdErrFile, exit, backtrace, dladdr, fprintf

	fprintf(StdErrFile.*, "\nFae Panic!\n".pointer)

	let null = null_pointer<void>()
	// 50 items
	let buffer = []&void {
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
		null, null, null, null, null, null, null, null, null, null,
	}

	let symbol_count = backtrace(buffer.pointer, buffer.length.(i32)).(isize)

	mut index: isize = 0
	while index < symbol_count {
		let address = buffer[index]
		index += 1

		mut info = DlInfo {
			dli_fname: null_pointer<u8>()
			dli_fbase: null_pointer<void>()
			dli_sname: null_pointer<u8>()
			dli_saddr: null_pointer<void>()
		}

		if dladdr(address, info.&mut) == 0 => continue
		if info.dli_saddr.(usize) == 0 => continue

		fprintf(StdErrFile.*, "%s\n".pointer, info.dli_sname)
	}

	fae::intrinsics::debugger_break()
	exit(-1)
}

#lang "range_type"
struct Range {
	start: isize
	end: isize
}

// TODO: This is temporary intermediate tool until there is "blessed" optional semantics
// baked into the language itself
generic T
enum Option {
	None
	Some(T)
}

method Option
fn unwrap(): T {
	match self {
		some: Some => return some

		None {
			let stderr = fae::libc::StdErrFile.*
			fae::libc::fprintf(stderr, "Panic: Attempted to unwrap an empty Option\n".pointer)
			fae::libc::fflush(stderr)
			fae::libc::exit(-1)
		}
	}
}
