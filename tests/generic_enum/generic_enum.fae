// Important note: This is not how error handling is intended to be done in Fae
// This is a contrived program intended to test generic enums

import fae::stdout::print_i32, print_newline

fn divide(value: i32, by: i32): Enum<i32, str> {
	if by == 0 => return .Error { value: "Divide by zero" }
	return .Ok { value: value / by }
}

fn main() {
	match divide(4, 0) {
		result: Ok {
			print_i32(result.value)
			print_newline()
		}

		error: Error => print_error<i32>(error)
	}

	let result = divide(4, 0)
	if result is Ok {
		print_i32(result.value)
		print_newline()
	} else if result is error: Error {
		print_error<i32>(error)
	}

	match divide(4, 2) {
		result: Ok {
			print_i32(result.value)
			print_newline()
		}

		error: Error => print_error<i32>(error)
	}

	let result = divide(4, 2)
	if result is Ok {
		print_i32(result.value)
		print_newline()
	} else if result is error: Error {
		print_error<i32>(error)
	}
}

generic T, E
enum Enum {
	Ok { value: T }
	Error { value: E }
}

generic T
fn print_error(arg: Enum<T, str>.Error) {
	import fae::stdout::print_string

	print_string("Error: ")
	print_string(arg.value)
	print_newline()
}
