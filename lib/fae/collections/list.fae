import fae::libc::realloc
import fae::memory::free_slice

generic T
struct List {
	items: []mut T readable
	capacity: isize readable
}

method static List
fn new(): List<T> {
	return List<T> {
		items: null_slice<T>()
		capacity: 0
	}
}

method mut List
fn push(item: T) {
	if self.items.length + 1 >= self.capacity {
		mut new_capacity = self.capacity * 2
		if new_capacity == 0 => new_capacity = 4
		self.reserve_capacity(new_capacity)
	}

	let index = self.items.length
	self.items.length += 1
	self.items[index] = item
}

method mut List
fn clear() {
	self.items.length = 0
}

method mut List
fn truncate(to_length: isize) {
	if to_length >= self.items.length => return
	self.items.length = to_length
}

method mut List
fn set_length(to_length: isize) {
	self.items.length = to_length
}

method mut List
fn reserve_capacity(new_capacity: isize) {
	let new_size = size_of<T>() * new_capacity
	let pointer = realloc(self.items.pointer.(&mut u8), new_size.(usize))
	self.items.pointer = pointer.(&mut T)
	self.capacity = new_capacity
}

method mut List
fn extend_from_slice(slice: []T) {
	let result_length = self.items.length + slice.length
	self.reserve_capacity(result_length)
	let destination = self.items[self.items.length..result_length]
	fae::memory::copy_slice_into<T>(slice, destination)
	self.items.length = result_length
}

method mut List
fn remove_range(range: Range) {
	let source = self.items[range.end..self.items.length]
	let destination = self.items[range.start..self.items.length]
	fae::memory::move_slice_into<T>(source, destination)
	self.truncate(range.start + source.length)
}

method List
fn is_empty(): bool {
	return self.items.length <= 0
}

method List
fn has_items(): bool {
	return self.items.length > 0
}

method List
fn last(): Option<T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1]
	return .Some(value)
}

method List
fn last_ref(): Option<&T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1].&
	return .Some(value)
}

method mut List
fn last_mut(): Option<&mut T> {
	if self.is_empty() => return .None
	let value = self.items[self.items.length - 1].&mut
	return .Some(value)
}

method List
fn get(index: isize): T {
	return self.items[index]
}

method List
fn get_ref(index: isize): &T {
	return self.items[index].&
}

method mut List
fn get_mut(index: isize): &mut T {
	return self.items[index].&mut
}

method List
fn slice(range: Range): []T {
	return self.items[range]
}

method mut List
fn slice_mut(range: Range): []mut T {
	return self.items[range]
}

method List
fn free() {
	free_slice<T>(self.items)
}
